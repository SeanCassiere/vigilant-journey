import{H3Event as p,getRequestURL as _,getRequestWebStream as P,eventHandler as v}from"h3";import{AsyncLocalStorage as x}from"node:async_hooks";function S(t={}){let e,n=!1;const i=o=>{if(e&&e!==o)throw new Error("Context conflict")};let r;if(t.asyncContext){const o=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;o?r=new o:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const s=()=>{if(r&&e===void 0){const o=r.getStore();if(o!==void 0)return o}return e};return{use:()=>{const o=s();if(o===void 0)throw new Error("Context is not available");return o},tryUse:()=>s(),set:(o,a)=>{a||i(o),e=o,n=!0},unset:()=>{e=void 0,n=!1},call:(o,a)=>{i(o),e=o;try{return r?r.run(o,a):a()}finally{n||(e=void 0)}},async callAsync(o,a){e=o;const u=()=>{e=o},l=()=>e===o?u:void 0;y.add(l);try{const f=r?r.run(o,a):a();return n||(e=void 0),await f}finally{y.delete(l)}}}}function T(t={}){const e={};return{get(n,i={}){return e[n]||(e[n]=S({...t,...i})),e[n],e[n]}}}const d=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},h="__unctx__",A=d[h]||(d[h]=T()),E=(t,e={})=>A.get(t,e),g="__unctx_async_handlers__",y=d[g]||(d[g]=new Set);function H(t){let e;const n=b(t),i={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(n,{...i,body:t.node.req.body}):new Request(n,{...i,get body(){return e||(e=I(t),e)}})}function C(t){return t.web??={request:H(t),url:b(t)},t.web.request}function L(){return U()}const w=Symbol("$HTTPEvent");function q(t){return typeof t=="object"&&(t instanceof p||t?.[w]instanceof p||t?.__is_event__===!0)}function R(t){return function(...e){let n=e[0];if(q(n))e[0]=n instanceof p||n.__is_event__?n:n[w];else{if(!globalThis.app.config.server.experimental?.asyncContext)throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");if(n=L(),!n)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");e.unshift(n)}return t(...e)}}const b=R(_),I=R(P);function $(){return E("nitro-app",{asyncContext:!!globalThis.app.config.server.experimental?.asyncContext,AsyncLocalStorage:x})}function U(){return $().use().event}const W=[{path:"/__root",filePath:"/Users/seanc/code/demo/start-with-build-output/app/routes/__root.tsx"},{path:"/api/hello",filePath:"/Users/seanc/code/demo/start-with-build-output/app/routes/api.hello.ts",$APIRoute:{src:"app/routes/api.hello.ts?pick=Route",build:()=>import("../api.hello.js"),import:()=>import("../api.hello.js")}},{path:"/",filePath:"/Users/seanc/code/demo/start-with-build-output/app/routes/index.tsx"}],B=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function D(t){return v(async e=>{const n=C(e);return await t({request:n})})}const K=t=>e=>({path:t,methods:e});function N(t,e){const n=t.pathname.split("/").filter(Boolean),i=e.sort((r,s)=>{const o=r.routePath.split("/").filter(Boolean);return s.routePath.split("/").filter(Boolean).length-o.length}).filter(r=>{const s=r.routePath.split("/").filter(Boolean);return n.length>=s.length});for(const r of i){const s=r.routePath.split("/").filter(Boolean),o={};let a=!0;for(let u=0;u<s.length;u++){const l=s[u],f=n[u];if(l.startsWith("$"))if(l==="$"){const c=n.slice(u).join("/");if(c!=="")o["*"]=c,o._splat=c;else{a=!1;break}}else{const c=l.slice(1);o[c]=f}else if(l!==f){a=!1;break}}if(a)return{routePath:r.routePath,params:o,payload:r.payload}}}const m=W.filter(t=>t.$APIRoute);function F(t){const e=[];return t.forEach(n=>{const r=n.path.split("/").filter(Boolean).map(s=>s==="*splat"?"$":s.startsWith(":$")&&s.endsWith("?")?s.slice(1,-1):s).join("/");e.push({routePath:`/${r}`,payload:n})}),e}const G=async({request:t})=>{if(!m.length)return new Response("No routes found",{status:404});if(!B.includes(t.method))return new Response("Method not allowed",{status:405});const e=F(m),n=new URL(t.url,"http://localhost:3000"),i=N(n,e);if(!i)return new Response("Not found",{status:404});let r;try{r=await i.payload.$APIRoute.import().then(a=>a.Route)}catch(a){return console.error("Error importing route file:",a),new Response("Internal server error",{status:500})}if(!r)return new Response("Internal server error",{status:500});const s=t.method,o=r.methods[s];return o?await o({request:t,params:i.params}):new Response("Method not allowed",{status:405})};export{K as a,D as c,G as d};
